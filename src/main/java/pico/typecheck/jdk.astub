import qual.Mutable;
import qual.Immutable;
import qual.ReceiverDependantMutable;
import qual.Readonly;
import qual.ObjectIdentityMethod;

package java.lang;

@ReceiverDependantMutable
class Object {
  @ReceiverDependantMutable Object();
  Class<?> getClass(@Readonly Object this);
  String toString(@Readonly Object this);
  @OnlyDependantOnAbstractStateField
  int hashCode(@Readonly Object this);
  @OnlyDependantOnAbstractStateField
  boolean equals(@Readonly Object this, @Readonly Object var1);
  @ReceiverDependantMutable Object clone(@ReceiverDependantMutable Object this);
}

class String {
  int length(@Immutable String this);
  char charAt(@Immutable String this, int var1);
  String substring(@Immutable String this, int var1);
  String substring(@Immutable String this, int var1, int var2);
  String toString(@Immutable String this);
  boolean equals(@Immutable Object var1);
  static String valueOf(@Readonly Object var0);
  static String format(String var0, @Readonly Object... var1);
}

class StringBuilder {
  StringBuilder append(@Readonly Object var1);
}

@ReceiverDependantMutable
class Throwable {
  String getMessage(@ReceiverDependantMutable Throwable this);
  String getLocalizedMessage(@ReceiverDependantMutable Throwable this);
  Throwable getCause(@ReceiverDependantMutable Throwable this);
  void printStackTrace(@ReceiverDependantMutable Throwable this);
  void printStackTrace(@ReceiverDependantMutable Throwable this, PrintStream var1);
  void printStackTrace(@ReceiverDependantMutable Throwable this, Throwable.PrintStreamOrWriter var1);
}

@Immutable
interface CharSequence {}

@ReceiverDependantMutable
class RuntimeException {
  RuntimeException(@Readonly Throwable var1);
  RuntimeException(String var1, @Readonly Throwable var2, boolean var3, boolean var4);
}

@Immutable
class Enum<E extends Enum<E>> {
  @Immutable Enum(String name, int ordinal);
}

package java.util;

@ReceiverDependantMutable
class Date {
  @ReceiverDependantMutable Date();
  @ReceiverDependantMutable Date(long var1);
  int getHours(@ReceiverDependantMutable Date this);
}

@ReceiverDependantMutable
interface Collection<E> {
  boolean contains(@Readonly Collection<E> this, @Readonly Object o);
}

@ReceiverDependantMutable
class ArrayList<E> {
  @ReceiverDependantMutable ArrayList();
  @ReceiverDependantMutable ArrayList(@Readonly Collection<? extends E> var1);
  boolean add(@Mutable ArrayList<E> this, E var1);
}

@ReceiverDependantMutable
interface List<E> {
  E get(@Readonly List<E> this, int index);
  boolean contains(@Readonly List<E> this, @Readonly Object o);
  boolean remove(@Readonly Object o);
}

@ReceiverDependantMutable
class AbstractList<E> {
  @ReceiverDependantMutable AbstractList();
  void add(@Mutable AbstractList<E> this, int var1, E var2);
}

@ReceiverDependantMutable
interface Set<E> {
  boolean contains(@Readonly Set<E> this, @Readonly Object var1);
}

@ReceiverDependantMutable
class HashSet<E> {
  @ReceiverDependantMutable HashSet();
  @ReceiverDependantMutable HashSet(@Readonly Collection<? extends E> var1);
  boolean contains(@Readonly HashSet<E> this, @Readonly Object var1);
  boolean remove(@Readonly Object var1);
}

@ReceiverDependantMutable
interface Map<K, V> {
  boolean containsKey(@Readonly Object var1);
  V get(@Readonly Map<K, V> this, @Readonly Object var1);
  Set<Map.Entry<K, V>> entrySet(@Readonly Map<K, V> this);
}

@ReceiverDependantMutable
class HashMap<K, V> {
  @ReceiverDependantMutable HashMap();
  @ReceiverDependantMutable HashMap(@Readonly Map<? extends K, ? extends V> var1);
  V get(@Readonly HashMap<K, V> this, @Readonly Object key);
  boolean containsKey(@Readonly HashMap<K, V> this, @Readonly Object key);
  boolean containsValue(@Readonly HashMap<K, V> this, @Readonly Object value);
}

class Arrays {
  static <T> @Immutable List<T> asList(T... var0);
  static String toString(int @Readonly [] var0);
  static boolean equals(float @Readonly [] var0, float @Readonly [] var1);
  static boolean equals(double @Readonly [] var0, double @Readonly [] var1);
}

@ReceiverDependantMutable
class Stack<E> {
  E peek(@ReceiverDependantMutable Stack<E> this);
  boolean empty(@ReceiverDependantMutable Stack<E> this);
}

@ReceiverDependantMutable
class Vector<E> {
  boolean isEmpty(@ReceiverDependantMutable Vector<E> this);
}

@ReceiverDependantMutable
class Hashtable<K,V> {
  V get(@Readonly Hashtable<K,V> this, @Readonly Object key);
  boolean containsKey(@Readonly Hashtable<K,V> this, @Readonly Object key);
}

package java.io;

@ReceiverDependantMutable
class PrintStream {
  void print(@ReceiverDependantMutable PrintStream this, String var1);
  PrintStream printf(@ReceiverDependantMutable PrintStream this, String var1, @Readonly Object... var2);
  PrintStream format(String format, @Readonly Object... args);
}

@ReceiverDependantMutable
class PrintWriter {
  PrintWriter printf(@ReceiverDependantMutable PrintWriter this, String var1, @Readonly Object... var2);
}

@ReceiverDependantMutable
class File {
  @ReceiverDependantMutable File(@Readonly File parent, String child);
  boolean isFile(@Readonly File this);
  String[] list(@Readonly File this);
  String getPath(@Readonly File this);
}

@ReceiverDependantMutable
class FileInputStream {
  @ReceiverDependantMutable FileInputStream(@Readonly File file);
}

class ObjectOutputStream {
  void writeObject(@Readonly Object obj);
}

package org.hibernate;
class Session {
  Object get(@Readonly Class clazz, @Readonly Serializable id);
}

package java.awt;

@ReceiverDependantMutable
class Container {
  void add(@Readonly Component comp, @Readonly Object constraints);
}
